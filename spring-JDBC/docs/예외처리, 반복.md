# 스프링과 문제 해결 - 예외처리, 반복

## 체크 예외와 인터페이스

- 서비스 계층은 순수하게 유지하는게 좋다. 예외에 대한 문제도 마찬가지다.
- `SQLException` 에 대한 의존을 제거하려면 어떻게?
- 서비스가 처리 불가능하므로 체크 → 언체크 변경해서 서비스로 던짐
- 서비스에서 해당 예외를 무시할 수 있고, 순수한 코드 유지 가능.

### 인터페이스 도입

- 멤버 레포지토리 인터페이스 도입
- 역시 답은 인터페이스
- 체크 예외를 사용해서 만들었다면 아래처럼 된다

    ```java
    public interface MemberRepositoryEx {
    	Member save(Member member) throws SQLException;
    	Member findById(String memberId) throws SQLException;
    	void update(String memberId, int money) throws SQLException;
    	void delete(String memberId) throws SQLException;
    }
    ```

  jdbc에 종속적인데 이러면? 서비스까지 코드가 전염될텐데



## 런타임 예외 적용

- 런타임 클래스

    ```java
    public class MyDbException extends RuntimeException {
    
        public MyDbException() {
        }
    
        public MyDbException(String message) {
            super(message);
        }
    
        public MyDbException(String message, Throwable cause) {
            super(message, cause);
        }
    
        public MyDbException(Throwable cause) {
            super(cause);
        }
    }
    ```

- 인터페이스

    ```java
    public interface MemberRepository {
        Member save(Member member);
        Member findById(String memberId);
        void update(String memberId, int money);
        void delete(String memberId);
    }
    ```

- 구현 클래스

    ```java
    public class MemberRepositoryV4_1 implements MemberRepository {
    
        private final DataSource dataSource;
    
        public MemberRepositoryV4_1(DataSource dataSource) {
            this.dataSource = dataSource;
        }
    
        @Override
        public Member save(Member member) {
            // sql 인젝션 예방 , 파라미터 바인딩
            String sql = "insert into member(member_id, money) values (?, ?)";
    
            Connection con = null;
            PreparedStatement pstmt = null;
    
            try{
                con = getConnection();
                pstmt = con.prepareStatement(sql);
                pstmt.setString(1, member.getMemberId());
                pstmt.setInt(2, member.getMoney());
                int count = pstmt.executeUpdate();
                return member;
            } catch (SQLException e) {
                throw new MyDbException(e); // 여기가 변경 -> 런타임
            }finally {
                
                close(con, pstmt, null);
            }
        }
      }
    ```


- 서비스 단

    ```java
    @Slf4j
    public class MemberServiceV4 {
    
        private final MemberRepository memberRepository;
    
        public MemberServiceV4(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
    
        @Transactional
        public void accountTransfer(String fromId, String toId, int money) {
                bizLogic(fromId, toId, money);
        }
    
        private void bizLogic(String fromId, String toId, int money) {
            Member fromMember = memberRepository.findById(fromId);
    
            Member toMember = memberRepository.findById(toId);
    
            memberRepository.update(fromId, fromMember.getMoney() - money);
            validation(toMember);
            memberRepository.update( toId, toMember.getMoney() + money);
        }
    
        private void validation(Member toMember) {
            if (toMember.getMemberId().equals("ex")) {
                throw new IllegalStateException("이체중 예외 발생");
            }
        }
    }
    ```


인터페이스와 런타임 클래스만 적용했을 뿐인데 모든 예외 오염 코드를 정리 할 수 있었다 ㅜㅜ


## 예외 처리 , 반복

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5ff62ebc-d86e-4469-bebc-9b687604901a/6bf58582-a079-48db-8992-9f51fb1a4fa0/Untitled.png)

- 스프링은 데이터 접근 계층에 대한 수십가지 예외를 정리해서 일관된 예외 계층을 제공.
- 각각의 예외는 특정 기술에 종속적이지 않게 설계되어 있다. 따라서 서비스 계층에서 스프링이 제공하는 예외를 사용하면 된다.
- `DataAccessException` : 데이터 접근 계층 런타임 예외
  - `Transient` : 일시적이라는 뜻.  `Transient` 하위 예외는 동일한 SQL을 다시 시도 했을 때 성공할 가능성 있음.
    - 쿼리 타임 아웃, 락과 관련된 오류. DB 상태가 좋아지거나 락이 풀렸을 때 다시 시도하면 성공한다.
  - `NonTransient`  : 일시적이지 않다는 뜻.
    - SQL 문법 오류, DB 제약 조건 위배 등.

### 스프링이 제공하는 예외 변환기

스프링이 미리 만들어 놓은  오류 변환기를 사용하자. 내가 언제 일일이 DB에 대한 예외를 짜고 있겠나.

```java

catch(SQLException e) {
    if (e.getErrorCode() == 23505) {
        throw new MyDuplicateKeyException(e);
    }
    throw new MyDbException(e);
}
```

이런 에러코드를 잡는 예외도 미리 만들어져 있을 거야.

```java
catch (SQLException e) {
    assertThat(e.getErrorCode()).isEqualTo(42122);

    SQLErrorCodeSQLExceptionTranslator exTranslator = 
    new SQLErrorCodeSQLExceptionTranslator(dataSource);

    // BadSqlGrammarException
    DataAccessException resultEx = exTranslator.translate("select", sql, e);
    log.info("resultEx", resultEx);
    assertThat(resultEx.getClass()).isEqualTo(BadSqlGrammarException.class);
}
```

- `SQLErrorCodeSQLExceptionTranslator` : 예외 변환기

sql-error-codes.xml 을 보면 이미 에러코드에 대비한 내용이 작성되어 있다.

```java
<bean id="H2" class="org.springframework.jdbc.support.SQLErrorCodes">
	<property name="badSqlGrammarCodes">
		<value>42000,42001,42101,42102,42111,42112,42121,42122,42132</value>
	</property>
	<property name="duplicateKeyCodes">
		<value>23001,23505</value>
	</property>
</bean>
<bean id="MySQL" class="org.springframework.jdbc.support.SQLErrorCodes">
	<property name="badSqlGrammarCodes">
		<value>1054,1064,1146</value>
	</property>
	<property name="duplicateKeyCodes">
		<value>1062</value>
	</property>
</bean>
```