# 스프링과 문제 해결 - 예외처리, 반복

## 체크 예외와 인터페이스

- 서비스 계층은 순수하게 유지하는게 좋다. 예외에 대한 문제도 마찬가지다.
- `SQLException` 에 대한 의존을 제거하려면 어떻게?
- 서비스가 처리 불가능하므로 체크 → 언체크 변경해서 서비스로 던짐
- 서비스에서 해당 예외를 무시할 수 있고, 순수한 코드 유지 가능.

### 인터페이스 도입

- 멤버 레포지토리 인터페이스 도입
- 역시 답은 인터페이스
- 체크 예외를 사용해서 만들었다면 아래처럼 된다

    ```java
    public interface MemberRepositoryEx {
    	Member save(Member member) throws SQLException;
    	Member findById(String memberId) throws SQLException;
    	void update(String memberId, int money) throws SQLException;
    	void delete(String memberId) throws SQLException;
    }
    ```

  jdbc에 종속적인데 이러면? 서비스까지 코드가 전염될텐데



## 런타임 예외 적용

- 런타임 클래스

    ```java
    public class MyDbException extends RuntimeException {
    
        public MyDbException() {
        }
    
        public MyDbException(String message) {
            super(message);
        }
    
        public MyDbException(String message, Throwable cause) {
            super(message, cause);
        }
    
        public MyDbException(Throwable cause) {
            super(cause);
        }
    }
    ```

- 인터페이스

    ```java
    public interface MemberRepository {
        Member save(Member member);
        Member findById(String memberId);
        void update(String memberId, int money);
        void delete(String memberId);
    }
    ```

- 구현 클래스

    ```java
    public class MemberRepositoryV4_1 implements MemberRepository {
    
        private final DataSource dataSource;
    
        public MemberRepositoryV4_1(DataSource dataSource) {
            this.dataSource = dataSource;
        }
    
        @Override
        public Member save(Member member) {
            // sql 인젝션 예방 , 파라미터 바인딩
            String sql = "insert into member(member_id, money) values (?, ?)";
    
            Connection con = null;
            PreparedStatement pstmt = null;
    
            try{
                con = getConnection();
                pstmt = con.prepareStatement(sql);
                pstmt.setString(1, member.getMemberId());
                pstmt.setInt(2, member.getMoney());
                int count = pstmt.executeUpdate();
                return member;
            } catch (SQLException e) {
                throw new MyDbException(e); // 여기가 변경 -> 런타임
            }finally {
                
                close(con, pstmt, null);
            }
        }
      }
    ```


- 서비스 단

    ```java
    @Slf4j
    public class MemberServiceV4 {
    
        private final MemberRepository memberRepository;
    
        public MemberServiceV4(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
    
        @Transactional
        public void accountTransfer(String fromId, String toId, int money) {
                bizLogic(fromId, toId, money);
        }
    
        private void bizLogic(String fromId, String toId, int money) {
            Member fromMember = memberRepository.findById(fromId);
    
            Member toMember = memberRepository.findById(toId);
    
            memberRepository.update(fromId, fromMember.getMoney() - money);
            validation(toMember);
            memberRepository.update( toId, toMember.getMoney() + money);
        }
    
        private void validation(Member toMember) {
            if (toMember.getMemberId().equals("ex")) {
                throw new IllegalStateException("이체중 예외 발생");
            }
        }
    }
    ```


인터페이스와 런타임 클래스만 적용했을 뿐인데 모든 예외 오염 코드를 정리 할 수 있었다 ㅜㅜ